}
get_lpc = function() {
return(.self$LPC)
}
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
}
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
}
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
}
save_mask = function(path) {
sf::st_write(.self$mask, path)
}
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
}
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
}
save_chm = function(path,) {
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character",
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
get_data = function() {
return(.self$xyz)
}
get_lpc = function() {
return(.self$LPC)
}
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
}
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
}
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
}
save_mask = function(path) {
sf::st_write(.self$mask, path)
}
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
}
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
}
save_chm = function(path) {
terra::writeRaster(.self$CHM, path, overwrite = TRUE)
}
save_pc = function(path) {
save(.self, file = path, overwrite = TRUE)
}
)
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character",
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
}
get_data = function() {
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character",
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
},
get_data = function() {
return(.self$xyz)
},
get_lpc = function() {
return(.self$LPC)
},
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
},
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
},
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
},
save_mask = function(path) {
sf::st_write(.self$mask, path)
},
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
},
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
},
save_chm = function(path) {
terra::writeRaster(.self$CHM, path, overwrite = TRUE)
},
save_pc = function(path) {
save(.self, file = path, overwrite = TRUE)
}
)
)
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character"
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
},
get_data = function() {
return(.self$xyz)
},
get_lpc = function() {
return(.self$LPC)
},
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
},
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
},
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
},
save_mask = function(path) {
sf::st_write(.self$mask, path)
},
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
},
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
},
save_chm = function(path) {
terra::writeRaster(.self$CHM, path, overwrite = TRUE)
},
save_pc = function(path) {
save(.self, file = path, overwrite = TRUE)
}
)
)
# # Save the S4 object to a .RData file
# save(my_s4, file = "my_s4.RData")
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_obj.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
citation(rlas)
citation("rlas")
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
library(lidR)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
dir <- "./data/"
mo_dir <- mo$new(dir)
print(mo_dir$metadata)
pc_14 <- spatial_container$new(mo_dir$metadata$file_path[1])
pc_19 <- spatial_container$new(mo_dir$metadata$file_path[2])
pc_19$set_crs(32617)
pc_19$LPC
pc_14$LPC
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
knitr::opts_chunk$set(echo = TRUE)
# Source the required scripts
source("app/global.R")
```{r , include=FALSE}
getwd()
# Source the required scripts
source("fmt/global.R")
source("r/spatial_container.R")
# Source the required scripts
source("fmt/global.R")
# Source the required scripts
source("fmt/global.R")
# Source the required scripts
source("r/functions.R")
getwd()
# Source the required scripts
source("/r/functions.R")
# Source the required scripts
source("C:/Users/cscar/FMT/r/functions.R")
source("C:/Users/cscar/FMT/r/spatial_container.R")
source("C:/Users/cscar/FMT/r/meta_obj.R")
# Source the required scripts
source("C:/Users/cscar/FMT/r/functions.R")
source("C:/Users/cscar/FMT/r/spatial_container.R")
source("C:/Users/cscar/FMT/r/meta_obj.R")
source("C:/Users/cscar/FMT/fmt/global.R")
source("C:/Users/cscar/FMT/fmt/global.R")
source("C:/Users/cscar/FMT/fmt/global.R")
knitr::opts_chunk$set(echo = TRUE)
# Source the required scripts
source("C:/Users/cscar/FMT/r/functions.R")
source("C:/Users/cscar/FMT/r/spatial_container.R")
source("C:/Users/cscar/FMT/r/meta_obj.R")
source("C:/Users/cscar/FMT/fmt/global.R")
dir <- "./data/"
mo_dir <- mo$new(dir)
knitr::opts_chunk$set(echo = TRUE)
wd <- getwd()
# Source the required scripts
source(paste0(wd,"/r/functions.R")
source(paste0(wd,"/r/spatial_container.R")
# Source the required scripts
source(paste0(wd,"/r/functions.R"))
paste0(wd,"r/functions.R")
paste0(wd,"/fmt/global.R")
wd
wd <- "C:/Users/cscar/FMT/"
source(paste0(wd,"fmt/global.R"))
# Source the required scripts
source(paste0(wd,"r/functions.R"))
source(paste0(wd,"r/spatial_container.R"))
source(paste0(wd,"r/meta_obj.R"))
source(paste0(wd,"fmt/global.R"))
dir <- paste0("/data/")
mo_dir <- mo$new(dir)
dir <- paste0(wd,"/data/")
dir <- paste0(wd,"/data/")
mo_dir <- mo$new(dir)
print(mo_dir$metadata)
spatial_container$methods()
#Loading and checking the point cloud data for 2014 and 2019
pc_14 <- spatial_container$new(mo_dir$metadata$file_path[1])
pc_14$set_crs(32617)
pc_14$LPC
pc_19 <- spatial_container$new(mo_dir$metadata$file_path[2])
pc_19$set_crs(32617)
pc_19$LPC
plot(pc_14$mask)
pc_14$to_dtm(1)
pc_19$to_dtm(1)
plot(pc_14$DTM)
pc_14$to_chm(1)
pc_19$to_chm(1)
plot(pc_19$CHM)
#This function aligns the two rasters and returns aligned raster objects.
aligned_chm <- process_raster(pc_14$CHM_raw, pc_19$CHM_raw, source_mask = pc_14$mask, target_mask = pc_19$mask, method = "bilinear")
# The align_chm saves the output layers as value in a list
source_chm <- aligned_chm[[1]]
target_chm <- aligned_chm[[2]]
chm_mask <- aligned_chm[[3]]
# Function to generate CHM and classify the differences
chm_diff_test <- CHM_diff_classify(source_chm, target_chm)
plot_stats(chm_diff_test)
# Display the outputs.
displayMap(pc_14$DTM,pc_14$CHM, chm_diff_test, chm_mask)
knitr::opts_chunk$set(echo = TRUE)
wd <- "C:/Users/cscar/FMT/"
# Source the required scripts
source(paste0(wd,"r/functions.R"))
source(paste0(wd,"r/spatial_container.R"))
source(paste0(wd,"r/meta_obj.R"))
source(paste0(wd,"fmt/global.R"))
