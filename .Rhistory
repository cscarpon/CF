filename = "character",
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
}
get_data = function() {
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character",
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
},
get_data = function() {
return(.self$xyz)
},
get_lpc = function() {
return(.self$LPC)
},
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
},
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
},
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
},
save_mask = function(path) {
sf::st_write(.self$mask, path)
},
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
},
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
},
save_chm = function(path) {
terra::writeRaster(.self$CHM, path, overwrite = TRUE)
},
save_pc = function(path) {
save(.self, file = path, overwrite = TRUE)
}
)
)
pc_obj <- setRefClass(
"point_cloud_container",
fields = list(
xyz = "data.frame",
LPC = "LAS",
CHM = "SpatRaster",
DTM = "SpatRaster",
hull = "sfc",
filepath =  "character",
filename = "character"
),
methods = list(
initialize = function(file_path = character(0)) {
lidR::set_lidr_threads(6)
.self$filepath <- file_path
.self$filename <- basename(file_path)
#Determine the extentsion of the filepath
ext <- tools::file_ext(file_path)
#create a dummy raster
dummy_spat <- terra::rast(extent = terra::ext(0, 1, 0, 1), res=1, vals=NA)
.self$DTM <- dummy_spat
.self$CHM <- dummy_spat
if (ext == "xyz") {
#read the x,y,z file
xyz_table <- read.table(file_path )
#add the names to the columns
names(xyz_table) <- c("X", "Y", "Z")
#add the xyz object to the xyz list
.self$xyz <<-  xyz_table
#create a last from the xyz object
las_xyz <- lidR::LAS(xyz_table)
#classify the ground points
ground <- lidR::classify_ground(las_xyz, algorithm = pmf(ws = 5, th = 3))
las_xyz@data$Classification <- ground@data$Classification
las_xyz@data$ReturnNumber <- 1
las_xyz@data$NumberOfReturns <- 1
#append the new las file to the list
.self$LPC <<- las_xyz
#Append the mask
.self$mask <<- mask_pc(las_xyz)
} else if (ext == "las" || ext == "laz") {
#Read the las files
las <- lidR::readLAS(file_path)
#append the new las file to the list
.self$LPC <<-  las
#Append the mask
.self$mask <<- mask_pc(las)
}
},
get_data = function() {
return(.self$xyz)
},
get_lpc = function() {
return(.self$LPC)
},
to_xyz = function(path) {
write.table(.self$xyz[,c("X", "Y", "Z")], path, row.names = FALSE, col.names = FALSE, quote = FALSE, sep = " ")
},
to_dtm = function(resolution = 1) {
dtm <- lidR::rasterize_terrain(.self$LPC, resolution, tin())
.self$DTM  <<- dtm
},
to_chm = function( resolution = 1) {
fill_na <- function(x, i=5) { if (is.na(x)[i]) { return(mean(x, na.rm = TRUE)) } else {return(x[i])}}
w <- matrix(1, 3, 3)
nlas <- lidR::normalize_height(.self$LPC,.self$DTM)
chm <- lidR::rasterize_canopy(nlas, resolution, p2r(0.2, na.fill = tin()))
filled <- terra::focal(chm, w, fun = fill_na)
clamp <- terra::clamp(filled, lower = 0)
.self$CHM <<- clamp
},
save_mask = function(path) {
sf::st_write(.self$mask, path)
},
save_las = function(path) {
lidR::writeLAS(.self$LPC, path)
},
save_dtm = function(path) {
terra::writeRaster(.self$DTM, path, overwrite = TRUE)
},
save_chm = function(path) {
terra::writeRaster(.self$CHM, path, overwrite = TRUE)
},
save_pc = function(path) {
save(.self, file = path, overwrite = TRUE)
}
)
)
# # Save the S4 object to a .RData file
# save(my_s4, file = "my_s4.RData")
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_obj.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
install.packages("shiny")
source("fmt/global.R")
install.packages("tidyverse")
source("fmt/global.R")
install.packages("leaflet")
source("fmt/global.R")
install.packages("reticulate")
source("fmt/global.R")
install.packages("gridExtra")
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
shiny::runApp('fmt')
runApp('fmt')
shiny::runApp('fmt')
runApp('fmt')
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
library(lidR)
las <- readLAS("C:\\Users\\cscar\\FMT\data\\TTP_2015.laz")
las <- readLAS("C:\\Users\\cscar\\FMT\\data\\TTP_2015.laz")
plot(las)
str(las)
unique(las$Classification)
test_ground <-unique(las$Classification)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
dir <- ("C:\\Users\\cscar\\FMT\\data)
dir <- ("C:\\Users\\cscar\\FMT\\data")
dir_files <- list.files(dir, pattern = ".laz || .las")
dir_files
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
writeLAS(las, "C:\\Users\\cscar\\FMT\\data\\TTP_2015.las")
dir <- ("C:\\Users\\cscar\\FMT\\data")
dir_files <- list.files(dir, pattern = ".laz || .las")
dir_files
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
test_ground
test_ground_extract <- [[test_ground] == 2]
test_ground_extract <- [test_ground] == 2
test_ground_extract <- [test_ground == 2]
renv::status
renv::update()
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
install.packages("opendatatoronto")
library(opendatatoronto)
library(dplyr)
# get package
package <- show_package("3143aae5-4aec-4646-bd3d-add7c639d3cc")
package
install.packages("RInno")
library(RInno)
library(terra)
image <- rast("C:/Users/cscar/Documents/Thesis/TTP_2021_Georeferenced.png")
test <- terra::rectify("C:/Users/cscar/Documents/Thesis/TTP_2021_Georeferenced.png")
test <- terra::rectify(image)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
install.packages("leaflet.extras")
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
# Load libraries
library(shiny) # builds the apps
library(dplyr) # data manipulation
library(rgl) # used for colour gradients
library(terra) # used for raster processing
library(lidR) # used for lidar processing
library(sf) # used for vector manipulation
library(ggplot2) # used for plotting
library(dplyr) # used for data manipulation
library(scales) # used for percent
library(leaflet) # used for interactive map
library(leaflet.extras) # used for dynamic legends
library(htmlwidgets)
library(reticulate) # python in r
library(gridExtra) # creates the grid index for density
options(shiny.reactlog = TRUE)
options(shiny.maxRequestSize = 1073741824)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
source("fmt/global.R")
source("fmt/server.R")
source("r/functions.R")
source("r/spatial_container.R")
source("r/meta_obj.R")
# Define the UI and server
ui <- source("fmt/ui.R", local = TRUE)$value
server <- source("fmt/server.R", local = TRUE)$value
# Run the app
shinyApp(ui = ui, server = server)
