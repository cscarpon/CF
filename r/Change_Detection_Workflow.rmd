---
title: "Change Detection Workflow"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Notes to Self

needed shortcuts for vscode : press Ctrl+Shift+V in the editor. You can view the preview side-by-side (Ctrl+K V) 
Ctrl+Shift+P Open Preview to the Side

```{r}


getwd()
```

## Running the dependancy scripts

These scripts will conenct the class, the functions and the global variables to the app.

```{r , include=FALSE}
# Source the required scripts
source("app/global.R")
source("r/functions.R")
source("r/spatial_obj.R")
```

## Class Structure of the Point Cloud Object

 The Class structure for the point cloud object can hold 
 a df, las, CHM (SpatRaster), DTM (SpatRaster), mask (sfc), filepath (character), filename (character)

  spatial_obj <- setRefClass(
   "point_cloud_obj",
    fields = list(
     data = "data.frame",
     LPC = "LAS",
     CHM = "SpatRaster",
     DTM = "SpatRaster",
     mask = "sfc",
     filepath =  "character",
     filename = "character"))

## Reading the Class Methods


The following function `spatial_obj$methods()` shows the methods of th spatial_obj class, which are inherited functions tof that object

```{r, echo=FALSE}
spatial_obj$methods()
```

## Custom methods

to call a method use `spatial_obj$method_name()`

initialize(spatial_obj, or .rdata),  
save_chm(spatial_obj$CHM, filepath) saves the currently stored CHM to the filepath,
save_dtm(.self$DTM, filepath)  saves the currently stored DTM to the filepath,
save_las(path), saves the LAS object `(.self$LPC)` to your path, include `.las` in the name
save_mask(path), saves the mask `(.self$mask)` to your path, include `.shp` in the name      
set_crs(crs), sets the crs of the current LPC
to_dtm(resolution), converts the current LPC to a DTM at the specified resolution
to_chm(resolution), converts the current LPC to a CHM at the specified resolution, it requires that a DTM is created. It will also classify ground if it is missing         
to_xyz(path), saves the current LPC to a xyz file at the specified path, include `.xyz` in the name
get_data(), saves the current dataframe to an external variable
get_meta(), saves the current meta to an external variable, this is required for the ICP registration
get_lpc(),  saves the current LPC to an external variable        


## Running the classes and initialising the object

The object needs to be created and initialised before it can be used. It can read either a `.rdata`, `.laz`, `.las`, or `.xyz `file.
On initialisation, an LPC object will be created regardless of the input format

to initialise the object use `spatial_obj$new(filepath)`

```{r, echo=FALSE} 
path_14 <- "C:/Users/User/Forest_Analyser_5000/data/TTP/LAS/Clipped/TTP_2014_decimate.laz"
pc_14 <- spatial_obj$new(path_14)

path_19 <- "C:/Users/User/Forest_Analyser_5000/data/TTP/LAS/Clipped/TTP_2019_decimate.laz"
pc_19 <- spatial_obj$new(path_19)
```

## Functions built with the class to help the processing of Point Cloud Data, Rasters, and Shapefiles

process_raster(source, target, mask_layer, method = "bilinear") - This function will align rasters and resample them to the target raster. It will also mask the target raster with the mask_layer
CHM_diff_classify(earlier, later) - This will do the differencencing of the CHMs and reclassify them
raster_stats(raster) this will produce statistcs about the chm diff raster, it only produces area per group for now
plot_stats(stats) plots the stats of the raster to the 2D plot consol
is_empty(raster) checks to see if the raster is empty and returns a boolean
is_empty_sfc(sfc)   checks to see if the sfc is empty and returns a boolean
mask_pc(pc)


```{r, echo=FALSE}







```

```


## The Tight Hull mask

A tight hull encloses the point cloud data and creates a boundary that represents the extent of 
the point cloud data. This is used to mask the point cloud data to help with alignment

```{r, echo=FALSE}
plot(pc_14$mask)
```


## Creating the Digital Terrain Models (DTM)

Digital Terrain Models (DTM) are created from the point cloud data using the `to_dtm()` method. These represent the bare earth surface.
The DTM will be saved inside the DTM slot of the class so that other instances of the class can access it.

The DTM is created using the `grid_terrain()` function from the `lidR` package. The `grid_terrain()` function uses a TIN algorithm to create a DTM from 
the point cloud data. The `grid_terrain()` function requires a resolution to be specified. 
The resolution is the size of the grid cells used to create the DTM. 
The resolution is specified in the units of the point cloud data. 



```{r, echo=FALSE} 
pc_14$to_dtm(1)
pc_19$to_dtm(1)

plot(pc_14$DTM)
```

```{r, echo=FALSE}

pc_14$DTM
```


## Creating the Canopy Height Model (CHM)

The Canopy Height Model (CHM) is created from the point cloud data using the `to_chm()` method. 
These values represent the raw heights of the trees in the point cloud data.
The CHM requires the DTM, where it will be used to subtract the elevations from the point cloud to leave the `normalised` heights of the trees


```{r, echo=FALSE}
pc_14$to_chm(1)
pc_19$to_chm(1)

plot(pc_14$CHM)

```

```{r, echo=FALSE}
pc_14$CHM
```


## Alignment of the CHM Rasters

The rasters need to be aligned so that their extents, resolution, and center pixels are the same.
The `align_rasters()` function from the `raster` package is used to align the rasters.


```{r, echo=FALSE} 


```

```{r, echo=FALSE} 
```

```{r, echo=FALSE} 
```

```{r, echo=FALSE} 
```

```{r, echo=FALSE} 
```

```{r, echo=FALSE} 
```